function magic_gene_set_tool(input_file1, input_file2, output_path, varargin)
% This function aims to build the differential gene set regulatory network
% from gene expression in input_file1 and input_file2 using the gene set
% categories introduced through varargin

    % Inputs:
        % - input_file1: Normalized gene expression under condition 1
        % - input_file2: Normalized gene expression under condition 2
        % - output_path: Directory where the output will be saved
        % - varargin: 
            % gene set categories from the Molecular Signatures Database (MSigDB) v3.1
            % Format: JSON


     % Outputs
        % gene_set_modulation.txt: Text file generated by the MAGIC algorithm. 
            % 6 columns:
                % Gene 1
                % Gene 2 
                    % indices of identified gene set pairs
                % Raw corr in M=1
                    % raw correlation of pair in Condition 2 samples
                % Raw corr in M=0
                    % raw correlation of pair in Condition 1 samples
                % P-value
                    % p-value of pair
                % Modulation Score
                    % value of the modulation score of the pair.
                    % Modulation scores that are closer to 1 indicate
                    % higher correlation in Condition 2 samples. 
        % network.tsv: Tab Seperated Values file
            % 4 columns
                % Target
                % Regulator
                    % Gene set indices of identified gene set pairs
                % Condition: 
                    % condition to which the interaction is attributed //
                    % condition under which the interaction is
                    % significantly observed
                % Weight
                    % weight of the edge, determined by the type of
                    % regulation/interaction
                    % 1 -> negative correlation under Condition 2
                    % 2 -> positive correlation under Condition 2
                    % -1 -> positive correlation under Condition 1
                    % -2 -> negative correlation under Condition 1

    %% Load gene expression data
    input1 = readtable(input_file1, 'Delimiter', '\t', 'FileType','text');
    input2 = readtable(input_file2,'Delimiter', '\t', 'FileType','text');
    
    
    input2_Excl = input2(:, 2:end); % to remove gene column
    % store gene names
    geneNames = input1{:,1};

    
    % To handle identical VariableNames/sample names across the two gene
    % expression data inputs: hash functions
    % prefix and sequential numbers for VariableNames using hash funct
    numVars = width(input2_Excl);
    prefix = 'var_';
    uniqueIDs = arrayfun(@(x) sprintf('%d', x), 1:numVars, 'UniformOutput', false);
    hashedNames = strcat(prefix, uniqueIDs);
    input2_Excl.Properties.VariableNames = hashedNames;

    total_data = [input1, input2_Excl];
    %combine tables to match data matrix required by MAGIC function
    data_matrix = double(total_data{:, 2:end});

    % Define GROUP
    num_vars_input1 = size(input1,2)-1; %subtract 1 for gene name column
    num_vars_input2 = size(input2_Excl, 2);
    
    % construct group vector required by MAGIC
    % assign 0 for data where modulator is not expressed, 1 for data where
    % modulator is expressed
    group = [zeros(1,num_vars_input1), ones(1,num_vars_input2)];
    
    
    
    % Sample size average
    % since our data is separate, we can take average of samples by taking 
    % number of variables (which represent samples) of each dataset and average
    % them
    equ_sam_size = (num_vars_input1 + num_vars_input1)/2;
    
    
    % Initialize with Default params

    bonf = 1;
    equ_sam_size = equ_sam_size;
    p_cutoff = 0.05;
    mod_score_cutoff = 0.6;

    %% Z-transformation on Gene Expression Data
    % Mean and Strandard Deviation for each gene
    mu = mean(data_matrix, 2); % col-wise
    s = std(data_matrix, 0, 2); % col-wise
    
    % z-value matrix
    Z = zeros(size(data_matrix));
    
    % z-transformation
    for k = 1:size(data_matrix,1)
        Z(k, group==0) = (data_matrix(k, group==0) - mu(k)) ./ s(k); % condition 1
        Z(k, group==1) = (data_matrix(k, group==1) - mu(k)) ./ s(k); % condition 2
    end
    %% Load Gene Set Catogries from json files
    all_gene_sets = {};

    for j=1:length(varargin)
        json_path = varargin{j};
        jsondata = jsondecode(fileread(json_path));

        geneSets = fieldnames(jsondata);
        sets = cell(1, numel(geneSets));

        for g=1:numel(geneSets)
            geneSetStruct = struct('name', geneSets{g}, 'genes', {jsondata.(geneSets{g}).geneSymbols});
            sets{g} = geneSetStruct;
        end

        sets = sets(cellfun(@(x) numel(x.genes) >= 20 && numel(x.genes) <= 500, sets));
        all_gene_sets = [all_gene_sets, sets];
    end   

    %% Gene Set Content Matrix
    gene_sets = cellfun(@(x) x.genes, all_gene_sets, 'UniformOutput',false);
   
    % gene set content matrix
    S = length(gene_sets); % Number of gene sets
    K = length(geneNames); % Number of genes
    G = zeros(S, K); 
    
    % for each gene set
    for s = 1:S
        n_s = length(gene_sets{s}); % number of genes in gene set 
    
        % for each each gene in gene set
        for k = 1:K
            gene = geneNames{k}; 
            % index of gene in gene set s
            gene_idx = find(strcmp(gene, gene_sets{s}));
            if ~isempty(gene_idx)
                % If gene is in gene set s, set G(s,k) = 1/n_s, else 0
                G(s,k) = 1 / n_s;
            end
        end
    end
    %% Gene Set Enrichment Score
    % not using dot(A,B) as MATLAB treats matrix dot product like the
    % collection of vectors, so identical dimensions for A and B needed. 
    
    % The * operator achieves the desired matrix
    ES_M = G*Z;
    
    % Filter based on L_0.05 criterion
    ES_std = std(ES_M,0,2);
    boundary = 1.96 * ES_std;
    
    l_boundary = ES_M - boundary;
    u_boundary = ES_M + boundary;
    
    within = (ES_M>= l_boundary) & (ES_M <= u_boundary);
    samples = size(Z,2);
    % Filter out if a gene set falls within boundary in more than 80% of
    % samples
    percentage_within = sum(within,2)/samples;
    filtered_gene_sets_indices = find(percentage_within <= 0.8);
    
    % remove the corresponding rows
    ES_M(filtered_gene_sets_indices, :) = [];
    
    % new matrix with filtered gene sets
    nonzero_rows = any(ES_M, 2);
    ES_M_filt = ES_M(nonzero_rows, :);
    
    
    %% Group Vector Approximation
    data = ES_M_filt;
    group = group;
    bonf = 1;
    equ_sam_size = equ_sam_size;
    p_cutoff = 0.05;
    mod_score_cutoff = 0.6;
    output_filename = fullfile(output_path,'gene_set_modulation');
    %% MAGIC
    [p1, p0, mod_score, adj_mat] = MAGIC(ES_M_filt, group, bonf, equ_sam_size, p_cutoff, mod_score_cutoff, output_filename);

    network = graph(adj_mat); % network(i,j) = [1 OR 2 OR 0 OR -2 OR -1]
    
    % extract genes which are ER-modulated
    geneset1_nodes = network.Edges.EndNodes(:,1);
    geneset2_nodes = network.Edges.EndNodes(:,2);
    % replace indices with gene names
    
    
    % extract modulation
    % 2: M=1 specific positive correlation; 1: M=1 specific negative correlation
    % -1: M=0 specific positive correlation; -2: M=0 specific negative correlation
    weights = network.Edges.Weight;
    
    
    %%
    % unique gene numbers (since we will create a new adjacency matrix)
    geneset_names = unique([geneset1_nodes; geneset2_nodes]);
    
    % new adjacency matrix
    % init symmetric adjacency matrix for only the modulated pairs
    num_nodes = length(geneset_names);
    new_adj_mat = zeros(num_nodes);
    
    
    % weights 
    for k = 1:length(geneset1_nodes)
        i = find(geneset_names == geneset1_nodes(k));
        j = find(geneset_names == geneset2_nodes(k));
        new_adj_mat(i, j) = weights(k);
        new_adj_mat(j, i) = weights(k); % symmetry
    end
    

    new_network = graph(new_adj_mat);
    
    
    % plot
    figure;
    plot(new_network, 'NodeLabel', {}, 'NodeFontSize', 5, 'LineWidth',0.2, 'Layout','circle', 'NodeColor',[0.5 0.7 1]);
    axis off;
    title("Differential Gene Set Regulatory Network");
    %% Output File
    % network.tsv
        % Col 1 -> target
        % Col 2 -> regulator
        % Col 3 -> condition ???
        % Col 4 -> Weight
    
    
    output_file = fullfile(output_path,'network.tsv');
    fid = fopen(output_file, 'w');
    
    % header
    fprintf(fid, 'Target\tRegulator\tCondition\tWeight\n');
    % due to the fact that obtaining the names of the gene sets was
    % difficult, the indices are being used instead
    target = geneset1_nodes;
    regulator = geneset2_nodes;
    w = weights; 
    
    % data
    for k = 1:length(geneset1_nodes)
        % condition column
        if w(k)>0
            condition ='Modulated';
        else 
            condition = 'Not Modulated';
        end
        fprintf(fid, '%d\t%d\t%s\t%d\n', target(k), regulator(k), condition, w(k));
    end
    
    
    fclose(fid);
    
    disp(['File ', output_file, ' created successfully!']);

end


